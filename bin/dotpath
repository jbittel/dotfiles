#!/usr/bin/env bash
#
# Given a path, converts it to a dotted Python module path.
# All additional parameters are concatenated onto the end
# of the dotpath. Dotted paths are passed through unmodified.
#
# E.g:
#   /home/user/work/ -> home.user.work
#   /home/user/code/test.py -> home.user.code.test
#   user/code/a.py Klass method -> user.code.a.Klass.method
#   user.code.b Klass -> user.code.b.Klass
#
set -o errexit
set -o nounset
set -o pipefail

_dir_to_dotpath() {
    local path="${1%/}"
    path="${path#/}"
    local dotpath="$(echo "${path}" | tr "/" ".")"
    echo "${dotpath}"
}

_file_to_dotpath() {
    local path="${1%.*}"
    path="${path#/}"
    local dotpath="$(echo "${path}" | tr "/" ".")"
    echo "${dotpath}"
}

_join() {
    local IFS=
    local sep="."
    local join_args="${1}"
    shift
    join_args+="${*/#/$sep}"
    echo "${join_args}"
}

path="${1}"
shift

dotpath=""

if [[ -d "${path}" ]]; then
    dotpath="$(_dir_to_dotpath ${path})"
elif [[ -f "${path}" ]]; then
    dotpath="$(_file_to_dotpath ${path})"
elif [[ "${path}" == *"."* ]]; then
    dotpath="${path}"
else
    echo "Error: ${path} is not a valid path" >&2
    exit 1
fi

if [[ -n "$@" ]]; then
    dotpath+=".$(_join "$@")"
fi

echo "${dotpath}"
